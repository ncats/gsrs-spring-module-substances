package ix.ginas.utils.validation;

import gsrs.DefaultDataSourceConfig;
import gsrs.module.substance.repository.ChemicalSubstanceRepository;
import gsrs.module.substance.repository.KeywordRepository;
import gsrs.module.substance.repository.SubstanceRepository;
import ix.core.models.Keyword;
import ix.core.models.Structure;
import ix.ginas.models.v1.ChemicalSubstance;
import ix.ginas.models.v1.GinasChemicalStructure;
import ix.ginas.models.v1.Substance;
import ix.ginas.models.v1.SubstanceReference;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import java.util.*;
import java.util.function.Predicate;
import java.util.stream.Collectors;

/**
 * Finds Chemical Structure Duplicates by looking at the hash property Keywords
 * that were generated by the Structure Processor.
 * Note: unlike the GSRS 2.x code for finding duplicates
 * this implementation will filter out the query substance we are searching
 * so there is no need to do a check to see if we got back the Substance
 * we passed in.
 */
@Component
@Slf4j
public class ChemicalDuplicateFinder implements DuplicateFinder<SubstanceReference> {

    @Autowired
    private SubstanceRepository substanceRepository;

    @Autowired
    private ChemicalSubstanceRepository chemicalSubstanceRepository;

    @Autowired
    private KeywordRepository keywordRepository;

    private final List<String> formulasOfCommonFragments = Arrays.asList("ClH", "Na", "H2O", "Cl", "K", "Ca", "C4H4O4", "H2O4S", "Br", "CH4O3S", "I", "H", "Mg", "BrH", "HO", "H4N", "Al", "Fe", "C2H4O2", "O", "Zn", "C4H6O6", "Cu", "H3O4P", "O4S", "C6H8O7", "Li", "C2H3O2", "CH3O4S", "Mn", "Co");

//    @Autowired
    @PersistenceContext(unitName =  DefaultDataSourceConfig.NAME_ENTITY_MANAGER)
    private EntityManager entityManager;
    /**
     * Currently uses the structure.properties.term keys for the duplicate matching
     */
    @Override
    public List<SubstanceReference> findPossibleDuplicatesFor(SubstanceReference subRef) {
        return findPossibleDuplicatesFor(subRef, 10);
    }

    /**
     * Find Possible Duplicates but only return the given max number of results.
     * @param subRef a reference to a substance of interest
     * @param max if set to 0 then there is no max number of results, if set to a positive number
     *            then limit the number of results to that number.
     * @return the list of results as SubstanceReferences.
     * @throws IllegalArgumentException if max &lt; 0.
     */
    public List<SubstanceReference> findPossibleDuplicatesFor(SubstanceReference subRef, int max) {
        if(max <0){
            throw new IllegalArgumentException("max must be >=0");
        }
        Map<UUID, SubstanceReference> dupMap = new LinkedHashMap<>();
        Substance sub = subRef.wrappedSubstance;
        if(sub ==null){
            sub = substanceRepository.findBySubstanceReference(subRef);
        }
        if(sub instanceof ChemicalSubstance) {
            //Hibernate/ Spring JPA repository queries could not easily do the
            //query like the GSRS 2.x with Play could where we looked for a String matching
            // structure.properties.term = $hash
            // because the properties was a Value superclass and term is only a Keyword and I could not
            // get it to downcast inside a collection.
            //
            //so instead I do a Keyword sarch to find all Keyword object that have that Term
            //and then I do a JPA query to find all the structure properties that contain that Keyword object.
            ChemicalSubstance cs = (ChemicalSubstance) sub;
            GinasChemicalStructure structure = cs.getStructure();

            String hash = structure.getStereoInsensitiveHash();

            List<Keyword> keywords = keywordRepository.findByTerm(hash);


            if (!keywords.isEmpty() && !isCommonFragment(structure)) {
                Substance ourSubstance = sub;
                int chunkSize=100;
                Predicate<ChemicalSubstance> skipOurselvesFilter = s-> !(ourSubstance.getUuid().equals(s.getUuid()));

                //for something like a common salt we might have thousands of keywords because the moieties
                //will all have the same hash
                //some DBs have a limit for the max number of items in an IN query list
                if(keywords.size() <= chunkSize) {
                    dupMap =
                            chemicalSubstanceRepository.findByStructure_PropertiesIn(keywords)
                                    .stream()
                                    .filter(skipOurselvesFilter)
                                    .limit(max)

                                    .collect(Collectors.toMap(Substance::getUuid, Substance::asSubstanceReference, (x, y) -> y, LinkedHashMap::new));
                }else{
                    //split it up
                    int current=0;
                    List<Keyword> subList;
                    do{
                        subList = keywords.subList(current, Math.min(keywords.size(), current+chunkSize));
                        current+=chunkSize;
                        List<ChemicalSubstance> initialResults=chemicalSubstanceRepository.findByStructure_PropertiesIn(subList);
                        dupMap.putAll(initialResults
                                        .stream()
                                        .filter(skipOurselvesFilter)
                                        .limit(max)

                                        .collect(Collectors.toMap(Substance::getUuid, Substance::asSubstanceReference, (x, y) -> y, LinkedHashMap::new)));

                    }while((max ==0 || dupMap.size()< max) && keywords.size()> current);

                }
                if (max >0 && dupMap.size() < max) {
                    if(keywords.size() <= chunkSize) {
                        dupMap.putAll(
                                chemicalSubstanceRepository.findByMoieties_Structure_PropertiesIn(keywords)
                                        .stream()
                                        .filter(skipOurselvesFilter)
                                        .limit(max - dupMap.size())
                                        .collect(Collectors.toMap(Substance::getUuid, Substance::asSubstanceReference, (x, y) -> y, LinkedHashMap::new)));
                    }else{
                        //split it up
                        int current=0;
                        List<Keyword> subList;
                        do{
                            subList = keywords.subList(current, Math.min(keywords.size(), current+chunkSize));
                            current+=chunkSize;
                            dupMap.putAll(chemicalSubstanceRepository.findByMoieties_Structure_PropertiesIn(subList)
                                            .stream()
                                            .filter(skipOurselvesFilter)
                                            .limit(max- dupMap.size())
                                            .collect(Collectors.toMap(Substance::getUuid, Substance::asSubstanceReference, (x, y) -> y, LinkedHashMap::new)));

                        }while((max ==0 || dupMap.size()< max) && keywords.size()> current);
                    }

                }
            }
        }
        
        return dupMap.values().stream()

                                .collect(Collectors.toList());
    }
    
    public static ChemicalDuplicateFinder instance(){
        return new ChemicalDuplicateFinder();
    }

    private boolean isCommonFragment(Structure structure) {
        log.trace("isCommonFragment about to return {}", formulasOfCommonFragments.contains(structure.formula));
        return formulasOfCommonFragments.contains(structure.formula);
    }
}
